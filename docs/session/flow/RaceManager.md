# RaceManager

RaceManager координирует всю гонку как единое целое: он знает, какая трасса загружена, какую машину выбрал игрок, сколько кругов нужно проехать и когда считать заезд завершённым. При запуске сцены компонент ищет RaceTrack и RaceHUD, считывает из GameSession выбранное количество кругов или, при его отсутствии, подставляет значение по умолчанию из поля defaultLaps у трассы. После этого RaceManager вызывает SpawnGridWithAI, чтобы расставить на стартовой решётке машину игрока и нужное количество ботов, а затем запускает корутину RaceRoutine, управляющую жизненным циклом гонки от обратного отсчёта до финишного экрана.

При формировании стартовой решётки в SpawnGridWithAI менеджер сначала извлекает выбранный игроком CarSpec из GameSession и проверяет, что у него есть валидный префаб машины. В качестве якоря для сетки используется playerSpawn из RaceTrack, а если он не задан, берётся позиция самого объекта RaceManager. Далее при помощи размера GizmoSize первого чекпоинта оценивается фактическая ширина трассы, вычисляется безопасное поперечное смещение для двух колонок, и на основании настроек gridLateralSpacing и gridLongitudinalSpacing строится список поз Grid, в котором первой позицией всегда идёт машина игрока. Для неё создаётся объект, назначается тег Player, подтягивается CarController, добавляется или находится LapTracker и инициализируется с учётом количества чекпоинтов. Если в сцене присутствует MobileInputProvider, он назначается только игроку, а все камеры и AudioListener внутри машинного префаба активируются и помечаются как главные, одновременно отключая лишние слушатели в других частях сцены.

Для ботов RaceManager собирает пул возможных CarSpec из ScriptableObject-каталога, опционально исключая модель, выбранную игроком. В зависимости от настроек либо используется явный prefab-override для всех ботов, либо из пула случайно выбираются модели. Для каждого бота создаётся объект на соответствующей позиции решётки, отключаются все компоненты ввода, связанные с мобильным управлением, добавляется LapTracker и AIDriver. ИИ настраивается так, чтобы использовать ту же трассу, ту же ленту TrackRibbon, а также корректные маски слоёв для стен и других автомобилей. Камеры и AudioListener внутри ботов принудительно выключаются, а весь объект рекурсивно переводится в слой Vehicles, чтобы физика и системы обнаружения трафика работали согласованно с AIDriver.

До начала гонки все участники замораживаются через SetAllFrozen: у каждого Rigidbody включается режим isKinematic, скорости обнуляются, а скрипты управления временно отключаются. Основной игровой цикл реализован в RaceRoutine. Сначала, если HUD существует, проигрывается визуальный и звуковой обратный отсчёт с заданной длительностью countdownSeconds. По его окончании RaceManager снимает заморозку, разрешает AIDriver двигаться, послав сигнал зелёного флага, и вызывает StartRacing у всех LapTracker, тем самым запуская подсчёт кругов. Пока флаг raceRunning активен, в каждом кадре RaceRoutine обновляет общий таймер на HUD, а также лучший круг игрока, если он уже зафиксирован.

Обратная связь с LapTracker устроена через два публичных метода: OnLapCompleted и OnCarFinished. Первый вызывается каждый раз, когда любой участник закрывает круг: RaceManager проверяет, принадлежит ли трекер игроку, и, если да, обновляет значение лучшего круга и отображает его в HUD. Второй вызывается при полном завершении дистанции конкретной машиной, когда LapTracker передаёт список всех времён кругов. Менеджер добавляет трекер в список финишировавших и, как только их количество достигает значения endAfterTop, останавливает гонку: замораживает все машины, выводит на HUD сообщение о завершении заезда и через WireExit перевязывает кнопку выхода на переход в главное меню, вызывая соответствующий метод GameSession. Такой подход хорошо согласуется с общими рекомендациями Unity о том, как организовывать длительные процессы с помощью корутин и событий, в частности с примерами использования метода StartCoroutine в официальной документации.
